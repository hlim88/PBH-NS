/* This code was generated by rnpl, a numerical programming language */
/* copyright (c) 1994-1998 by Robert L. Marsa and Matthew W. Choptuik */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>
#include <signal.h>
#include <sdf.h>
#include <librnpl.h>

#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif

/*  This routine initializes the following grid functions 
    q1 q2 q3 p1 p2 p3 source1 source2 source3 flux1 flux2 flux3 a alpha 
*/
void initializer(double *q1_np1,double *q1_n,double *q2_np1,double *q2_n,double *q3_np1,double *q3_n,double *p1_np1,double *p1_n,double *p2_np1,double *p2_n,double *p3_np1,double *p3_n,double *source1_n,double *source2_n,double *source3_n,double *flux1_n,double *flux2_n,double *flux3_n,double *fluxAlt1_n,double *fluxAlt2_n,double *fluxAlt3_n,double *alpha_n,double *a_n,int g1_Nr,double *r)
{

/*
This array shuffling needs to be fixed...
*/
#include "initialData.h"
int length = g1_Nr;
int nVar = 3;
double *primVar = malloc(nVar*length*sizeof(double));
double *consVar = malloc(nVar*length*sizeof(double));
double *flux  = malloc(nVar*length*sizeof(double));
double *fluxAlt  = malloc(nVar*length*sizeof(double));
double *source = malloc(nVar*length*sizeof(double));
double *rFluid = malloc(nVar*length*sizeof(double));
	
int i;

/*
These are the coordinates of the centers of the fluid cells
*/
for(i=0; i<(length-1); i++){
	rFluid[i]=0.5*(r[i+1]+r[i]);
}
rFluid[length-1]=2.0*r[length-1]-rFluid[length-2];

//These values are not used
flux[(length-1)*nVar] = 0.0;
flux[(length-1)*nVar+1] = 0.0;
flux[(length-1)*nVar+2] = 0.0;


getInitialData(consVar, primVar, a_n, alpha_n, flux, fluxAlt, source, r, rFluid, length);

for(i=0; i<length; i++){
	
	q1_n[i] = consVar[i*nVar];
	q2_n[i] = consVar[i*nVar+1];
	q3_n[i] = consVar[i*nVar+2];
	
	p1_n[i] = primVar[i*nVar];
	p2_n[i] = primVar[i*nVar+1];
	p3_n[i] = primVar[i*nVar+2];

	flux1_n[i] = flux[i*nVar];
	flux2_n[i] = flux[i*nVar+1];
	flux3_n[i] = flux[i*nVar+2];

	fluxAlt1_n[i] = fluxAlt[i*nVar];
	fluxAlt2_n[i] = fluxAlt[i*nVar+1];
	fluxAlt3_n[i] = fluxAlt[i*nVar+2];

	source1_n[i] = source[i*nVar];
	source2_n[i] = source[i*nVar+1];
	source3_n[i] = source[i*nVar+2];
	
}

free(primVar);
free(consVar);
free(flux);
free(fluxAlt);
free(source);
free(rFluid);
}

